<!-- Path: interactive-guilloche-vr/guilloche_kaleidoscope_360.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Immersive 360° Guilloche Kaleidoscope</title>
    <meta name="description" content="Adapted guilloche pattern with kaleidoscopic symmetry in a 360° view, VR support.">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000000; color: #ffffff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display: block; background-color: rgba(0,0,0,0.5); padding: 5px 0; font-size: 12px; }
        #vr-button { position: absolute; bottom: 20px; right: 20px; z-index: 101; padding: 12px 24px; background-color: #333; color: #fff; border: 1px solid #fff; border-radius: 4px; cursor: pointer; font-size: 16px; display: none; }
        #vr-button:hover { background-color: #555; }
        #permission-button { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 15px; z-index: 102; background-color: #444; color: #fff; border: 1px solid #fff; border-radius: 5px; cursor: pointer; display: none; }
        a { color: #0af; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        Immersive 360° Guilloche Kaleidoscope by UnLovable<br/>
        Look around (Desktop: Mouse Drag, Mobile: Tilt Device, VR: Headset)
    </div>
    <button id="vr-button">Enter VR</button>
    <button id="permission-button">Enable Motion Control</button>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let controls = null;
        let sphereMesh;
        let shaderMaterial;
        let time = 0;
        let deviceOrientationControlsActive = false;
        let initialDeviceOrientation = null;
        let deviceOrientationListenerAdded = false;

        const uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            // u_mouse: { value: new THREE.Vector2(0.0, 0.0) }, // Not used in this pattern

            u_kaleidoscope_sectors: { value: 12.0 }, // From original shader
            u_pattern_scale: { value: 1.0 } // Adjust scale of the pattern mapping
        };

        // Simple pass-through vertex shader
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Adapted Fragment Shader from provided source
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_kaleidoscope_sectors;
            uniform float u_pattern_scale;
            varying vec2 vUv;

            #define PI 3.14159265359
            #define TWO_PI 6.28318530718

            // Based on work by Inigo Quilez
            vec3 palette( float t ) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263, 0.416, 0.557); // Original palette values
                return a + b*cos( TWO_PI*(c*t+d) );
            }

            void main() {
                // 1. Spherical Coords & Kaleidoscope
                float lon = vUv.x * TWO_PI;
                float lat = (vUv.y - 0.5) * PI; // Latitude from -PI/2 to PI/2

                float segment_angle = TWO_PI / u_kaleidoscope_sectors;
                float segment_index = floor(lon / segment_angle);
                lon = mod(lon, segment_angle);
                // Reflect based on segment index (corrected logic for seamlessness)
                if (mod(segment_index, 2.0) > 0.5) {
                    lon = segment_angle - lon;
                }

                // 2. Map to Pattern Space (similar to original UV mapping)
                // Map longitude [-seg/2, seg/2] and latitude [-PI/2, PI/2] to a scaled Cartesian space
                // We use the *modified* lon here
                vec2 pattern_uv;
                pattern_uv.x = (lon - segment_angle * 0.5) * u_pattern_scale; // Center the segment around 0
                pattern_uv.y = lat * u_pattern_scale;

                // Calculate equivalent polar coordinates in this pattern space
                float pattern_angle = atan(pattern_uv.y, pattern_uv.x); // Angle within the mapped segment
                float pattern_radius = length(pattern_uv);

                // 3. Guilloche Pattern Generation (adapted from original)
                float t = u_time * 0.1; // Time factor for animation

                float pattern = 0.0;
                // Use pattern_uv.x, pattern_uv.y, pattern_radius, pattern_angle
                // Corrected syntax: _ -> *
                pattern += sin(pattern_uv.x * 50.0 + t * 2.0) * sin(pattern_uv.y * 50.0 + t * 3.0) * 0.5;
                pattern += sin(pattern_uv.x * 30.0 + t * 1.5) * cos(pattern_uv.y * 40.0 + t * 2.5) * 0.3;
                pattern += cos(pattern_radius * 60.0 + t * 5.0) * 0.2; // Radial waves based on mapped radius
                // The original angle term might need adjustment based on how many full cycles we want per sector
                // Using pattern_angle directly might be too slow, scale it by sectors/2?
                pattern += sin(pattern_angle * u_kaleidoscope_sectors * 0.5 + t * 4.0) * 0.1; // Angular detail
                pattern += sin(pattern_radius * 100.0 + pattern_angle * 20.0 + t * 6.0) * 0.1;

                // 4. Apply animation and color
                float colorMix = sin(pattern * 10.0 + t * 5.0); // Mix based on pattern and time
                vec3 finalColor = palette(colorMix * 0.5 + 0.5); // Map to color palette

                // Add some glow/intensity based on pattern peaks
                // Corrected syntax: _= -> *=
                finalColor *= (1.0 + abs(pattern) * 0.5);

                // Remove vignette - not suitable for 360 view
                // float vignette = smoothstep(0.0, 0.8, pattern_radius) * smoothstep(2.0, 0.8, pattern_radius);
                // finalColor *= vignette;

                // Final color output
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 0.1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            const sphereGeometry = new THREE.SphereGeometry(500, 128, 64); // High-res sphere
            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, shaderMaterial);
            scene.add(sphereMesh);

            activateOrbitControls();
             if (controls instanceof OrbitControls) {
                controls.enablePan = false; controls.enableZoom = false;
                controls.rotateSpeed = -0.25; // Adjust rotation speed as needed
                controls.minDistance = 0; controls.maxDistance = 1;
            }

            const vrButtonElement = document.getElementById('vr-button');
            vrButtonElement.style.display = 'none';
            document.body.appendChild(VRButton.createButton(renderer, {
                onSessionStart: () => { deviceOrientationControlsActive = false; initialDeviceOrientation = null; },
                onSessionEnd: () => { activateOrbitControls(); checkDeviceOrientationSupport(); },
                onUnsupported: () => { vrButtonElement.textContent = "VR Not Supported"; vrButtonElement.disabled = true; vrButtonElement.style.display = 'block'; checkDeviceOrientationSupport(); },
                onSupported: () => { vrButtonElement.style.display = 'block'; checkDeviceOrientationSupport(); }
            }));

            window.addEventListener('resize', onWindowResize, false);
            // No mouse listener needed for this shader
        }

        function checkDeviceOrientationSupport() {
             const permissionButton = document.getElementById('permission-button');
            if (window.DeviceOrientationEvent) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    permissionButton.style.display = 'block';
                    permissionButton.onclick = () => {
                        DeviceOrientationEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') { if (!deviceOrientationListenerAdded) { window.addEventListener('deviceorientation', handleDeviceOrientation, true); deviceOrientationListenerAdded = true; } }
                                else { activateOrbitControls(); }
                                permissionButton.style.display = 'none';
                            }).catch(error => { permissionButton.style.display = 'none'; activateOrbitControls(); });
                    };
                } else { if (!deviceOrientationListenerAdded) { window.addEventListener('deviceorientation', handleDeviceOrientation, true); deviceOrientationListenerAdded = true; } }
            } else { activateOrbitControls(); }
        }

        function activateOrbitControls() {
            deviceOrientationControlsActive = false; initialDeviceOrientation = null;
            if (!(controls instanceof OrbitControls)) {
                if (controls && typeof controls.dispose === 'function') { controls.dispose(); }
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.05;
                controls.enablePan = false; controls.enableZoom = false;
                controls.rotateSpeed = -0.25; controls.minDistance = 0; controls.maxDistance = 1;
            } else { controls.enabled = true; }
        }

        function activateDeviceOrientationControls() {
            if (!deviceOrientationControlsActive && !renderer.xr.isPresenting) {
                if (controls instanceof OrbitControls) { controls.dispose(); controls = null; }
                deviceOrientationControlsActive = true; initialDeviceOrientation = null;
            }
        }

        function handleDeviceOrientation(event) {
             if (event.alpha === null && event.beta === null && event.gamma === null) { return; }
            if (!deviceOrientationControlsActive && !renderer.xr.isPresenting) { activateDeviceOrientationControls(); }
            if (deviceOrientationControlsActive && !renderer.xr.isPresenting) {
                const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0; const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0; const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0;
                if (initialDeviceOrientation === null && event.alpha !== null) { initialDeviceOrientation = { alpha: alpha, beta: beta, gamma: gamma }; }
                if (initialDeviceOrientation) { const euler = new THREE.Euler(beta - initialDeviceOrientation.beta, alpha - initialDeviceOrientation.alpha, gamma - initialDeviceOrientation.gamma, 'YXZ'); camera.quaternion.setFromEuler(euler); }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            time += 0.016;
            uniforms.u_time.value = time;

            if (controls instanceof OrbitControls) { controls.update(); }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
