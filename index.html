<!-- Path: interactive-guilloche-vr/guilloche_kaleidoscope_360.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Immersive 360° Guilloche Kaleidoscope - Production Ready</title>
    <meta name="description" content="Production-ready guilloche pattern with kaleidoscopic symmetry in a 360° view, featuring robust VR, Orbit, and Mobile Tilt controls.">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000000; color: #ffffff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display: block; background-color: rgba(0,0,0,0.5); padding: 5px 0; font-size: 12px; }
        /* VR button will be styled by Three.js, but we can add a default position */
        #vr-button-container { position: absolute; bottom: 20px; right: 20px; z-index: 101; }
        #permission-button { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 15px 25px; z-index: 102; background-color: #4CAF50; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        #permission-button:hover { background-color: #45a049; }
        a { color: #0af; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        Immersive 360° Guilloche Kaleidoscope by UnLovable<br/>
        Look around (Desktop: Mouse Drag, Mobile: Tilt Device, VR: Headset)
    </div>
    <div id="vr-button-container"></div>
    <button id="permission-button">Enable Motion Control</button>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let orbitControls = null;
        let sphereMesh;
        let shaderMaterial;
        let time = 0;

        let deviceOrientationListenerAdded = false;
        let initialDeviceOrientation = null; // Stores {alpha, beta, gamma} of first valid reading
        let currentDeviceQuaternion = new THREE.Quaternion(); // Stores the current device orientation

        // Control State Management
        const ControlType = { NONE: 0, ORBIT: 1, DEVICE_ORIENTATION: 2, VR: 3 };
        let activeControlType = ControlType.NONE;

        const uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            u_kaleidoscope_sectors: { value: 12.0 },
            u_pattern_scale: { value: 1.0 }
        };

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_kaleidoscope_sectors;
            uniform float u_pattern_scale;
            varying vec2 vUv;

            #define PI 3.14159265359
            #define TWO_PI 6.28318530718

            vec3 palette( float t ) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263, 0.416, 0.557);
                return a + b*cos( TWO_PI*(c*t+d) );
            }

            void main() {
                float lon = vUv.x * TWO_PI;
                float lat = (vUv.y - 0.5) * PI;
                float segment_angle = TWO_PI / u_kaleidoscope_sectors;
                float segment_index = floor(lon / segment_angle);
                lon = mod(lon, segment_angle);
                if (mod(segment_index, 2.0) > 0.5) {
                    lon = segment_angle - lon;
                }
                vec2 pattern_uv;
                pattern_uv.x = (lon - segment_angle * 0.5) * u_pattern_scale;
                pattern_uv.y = lat * u_pattern_scale;
                float pattern_angle = atan(pattern_uv.y, pattern_uv.x);
                float pattern_radius = length(pattern_uv);
                float t = u_time * 0.1;
                float pattern = 0.0;
                pattern += sin(pattern_uv.x * 50.0 + t * 2.0) * sin(pattern_uv.y * 50.0 + t * 3.0) * 0.5;
                pattern += sin(pattern_uv.x * 30.0 + t * 1.5) * cos(pattern_uv.y * 40.0 + t * 2.5) * 0.3;
                pattern += cos(pattern_radius * 60.0 + t * 5.0) * 0.2;
                pattern += sin(pattern_angle * u_kaleidoscope_sectors * 0.5 + t * 4.0) * 0.1;
                pattern += sin(pattern_radius * 100.0 + pattern_angle * 20.0 + t * 6.0) * 0.1;
                float colorMix = sin(pattern * 10.0 + t * 5.0);
                vec3 finalColor = palette(colorMix * 0.5 + 0.5);
                finalColor *= (1.0 + abs(pattern) * 0.5);
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Camera is at origin, looking into the sphere. Sphere is large.
            // We don't move camera.position; we rotate it.
            camera.position.set(0,0,0.01); // Slightly off origin to ensure it's "inside"

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            const sphereGeometry = new THREE.SphereGeometry(500, 128, 64);
            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, shaderMaterial);
            scene.add(sphereMesh);

            setupVRButton();
            initializeControls(); // Sets initial control scheme

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupVRButton() {
            const vrButtonContainer = document.getElementById('vr-button-container');
            const vrButton = VRButton.createButton(renderer);
            vrButtonContainer.appendChild(vrButton); // Add VR button to its designated container

            // VR session lifecycle managed by renderer.xr events
            renderer.xr.addEventListener('sessionstart', () => {
                console.log("VR Session Started");
                enableControls(ControlType.VR);
            });
            renderer.xr.addEventListener('sessionend', () => {
                console.log("VR Session Ended");
                // Revert to appropriate non-VR controls
                initializeControls(); 
            });
        }
        
        function initializeControls() {
            if (renderer.xr.isPresenting) {
                enableControls(ControlType.VR);
                return;
            }

            // Default to OrbitControls, then check for device orientation
            enableControls(ControlType.ORBIT);
            checkDeviceOrientationSupport();
        }

        function enableControls(type) {
            // Disable all first
            if (orbitControls) orbitControls.enabled = false;
            // No explicit "disable" for device orientation, just stop using its quaternion
            // VR is handled by renderer.xr

            activeControlType = type;
            console.log("Active control type:", Object.keys(ControlType).find(key => ControlType[key] === type));

            switch (type) {
                case ControlType.ORBIT:
                    if (!orbitControls) {
                        orbitControls = new OrbitControls(camera, renderer.domElement);
                        orbitControls.enableDamping = true;
                        orbitControls.dampingFactor = 0.05;
                        orbitControls.enablePan = false;
                        orbitControls.enableZoom = false;
                        orbitControls.rotateSpeed = -0.25; // Negative for natural swipe on sphere interior
                        orbitControls.minDistance = 0; 
                        orbitControls.maxDistance = 0.1; // Effectively locks zoom
                    }
                    orbitControls.enabled = true;
                    break;
                case ControlType.DEVICE_ORIENTATION:
                    // OrbitControls must be disabled for device orientation to work without conflict
                    if (orbitControls) orbitControls.enabled = false;
                    initialDeviceOrientation = null; // Reset for calibration
                    // The handleDeviceOrientation listener will now apply updates
                    break;
                case ControlType.VR:
                    if (orbitControls) orbitControls.enabled = false;
                    // VR controls are managed by the WebXRManager internally
                    break;
                case ControlType.NONE:
                     // All controls are off
                    break;
            }
        }


        function checkDeviceOrientationSupport() {
            if (renderer.xr.isPresenting) return; // Don't interfere if in VR

            const permissionButton = document.getElementById('permission-button');
            permissionButton.style.display = 'none'; // Hide by default

            if (window.DeviceOrientationEvent) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                if (!deviceOrientationListenerAdded) {
                                    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                                    deviceOrientationListenerAdded = true;
                                }
                                // If permission granted, attempt to switch to device orientation
                                // This needs to be explicit, as OrbitControls might be active.
                                enableControls(ControlType.DEVICE_ORIENTATION);
                            } else {
                                console.log("Device orientation permission not granted.");
                                // Fallback or ensure OrbitControls remain if DEVICE_ORIENTATION was not activated
                                if (activeControlType !== ControlType.ORBIT) enableControls(ControlType.ORBIT);
                            }
                            permissionButton.style.display = 'none'; // Hide after attempt
                        }).catch(error => {
                            console.error("DeviceOrientationEvent.requestPermission error:", error);
                            permissionButton.style.display = 'none';
                            if (activeControlType !== ControlType.ORBIT) enableControls(ControlType.ORBIT);
                        });
                    // Show button to trigger permission prompt
                    permissionButton.style.display = 'block';
                } else {
                    // Android or older iOS (permission is implicit or handled differently)
                    if (!deviceOrientationListenerAdded) {
                        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                        deviceOrientationListenerAdded = true;
                        console.log("Device orientation listener added (non-iOS13+ path).");
                        // Do not switch controls yet; wait for the first event in handleDeviceOrientation
                        // This ensures sensors are actually available.
                    }
                }
            } else {
                console.log("DeviceOrientationEvent not supported.");
                if (activeControlType !== ControlType.ORBIT) enableControls(ControlType.ORBIT);
            }
        }
        
        const SENSOR_FIX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2); // Correction for device coordinate system
        const WORLD_FIX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -Math.PI / 2); // Orient world Z to be user's forward

        function handleDeviceOrientation(event) {
            if (renderer.xr.isPresenting) return;

            // If this is the first event and we are on a non-iOS13+ path, switch controls
            if (activeControlType === ControlType.ORBIT && typeof DeviceOrientationEvent.requestPermission !== 'function') {
                 // Check for valid event data before switching
                if (event.alpha !== null || event.beta !== null || event.gamma !== null) {
                    console.log("First valid device orientation event received, switching controls.");
                    enableControls(ControlType.DEVICE_ORIENTATION);
                } else {
                    console.log("Device orientation event has null data, not switching yet.");
                    return; // Wait for valid data
                }
            }
            
            // Only apply if device orientation is the active control method
            if (activeControlType !== ControlType.DEVICE_ORIENTATION) return;

            const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0; // Z
            const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;   // X
            const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0; // Y

            if (event.alpha === null && event.beta === null && event.gamma === null) {
                console.warn("Device orientation event has all null data.");
                return;
            }
            
            const deviceEuler = new THREE.Euler(beta, alpha, -gamma, 'YXZ'); // Standard order for device orientation
            currentDeviceQuaternion.setFromEuler(deviceEuler);
            currentDeviceQuaternion.multiply(SENSOR_FIX); // Apply sensor correction
            currentDeviceQuaternion.multiply(WORLD_FIX); // Align to world

            if (initialDeviceOrientation === null) {
                // Capture the first fully processed orientation as the baseline
                initialDeviceOrientation = currentDeviceQuaternion.clone().invert();
                console.log("Initial device orientation captured.");
            }
            
            // Apply the relative orientation
            if (initialDeviceOrientation) {
                camera.quaternion.copy(initialDeviceOrientation).multiply(currentDeviceQuaternion);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            time += 0.016; 
            uniforms.u_time.value = time;

            if (activeControlType === ControlType.ORBIT && orbitControls && orbitControls.enabled) {
                orbitControls.update();
            }
            // For DEVICE_ORIENTATION, camera.quaternion is updated in handleDeviceOrientation
            // For VR, camera is updated by WebXRManager

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
